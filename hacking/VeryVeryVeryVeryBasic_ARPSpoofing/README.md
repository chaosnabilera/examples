## What we need (in same subnet)
* VM to execute ARPSpoofing.py
* Victim VM
* VM with IP forwarding + Web server(nginx)

## To test
* Turn on VMs
* Enable IP forwarding / Setup iptables / run web server
* Execute ARPSpoofing.py
* Test on Victim VM to see whether ARP spoofing works
    * Some how some websites work but others don't....
    * The reason seems to be some websites send RST fast enough so that Spoofed webpage cannot show up
    * This is veryveryveryvery basic anyway...

## enable IP forwarding
~~~
sysctl -w net.ipv4.ip_forward=1
~~~

## iptables settings
* Need to set as following:
	* iptables -t nat -F
		* Flush all settings in nat table
	* iptables -Z
		* Initialze all connection state
	* iptables -A FORWARD -i <interface name> -j ACCEPT
		* Allow packets that is routed through current firewall
	* iptables -t nat -A POSTROUTING -o <interface name> -j MASQUERADE
		* Change outgoing packet's IP to firewall's IP
	* iptables -t nat -A PREROUTING -p tcp --dport <port number 1> -j DNAT --to-destination <ip:port>
		* Change any packet that has specific destination port so that its destination ip and port is as specified by DNAT --to-destination

## iptables setting detail

### iptables -t nat -F
* TL;DR
	* Flush all the chains in nat table. In other words, delete all preexisting rules in nat table
* Details
	* -t, --table table
		* This option specifies the packet matching table which the command should operate on. If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.
		* The tables are as follows:
			* filter: This is the default table (if no -t option is passed). It contains the built-in chains INPUT (for packets destined to local sockets), FORWARD (for packets being routed through the box), and OUTPUT (for locally-generated packets).
			* nat: This table is consulted when a packet that creates a new connection is encountered. It consists of three built-ins: PREROUTING (for altering packets as soon as they come in), OUTPUT (for altering locally-generated packets before routing), and POSTROUTING (for altering packets as they are about to go out).
			* mangle: This table is used for specialized packet alteration. Until kernel 2.4.17 it had two built-in chains: PREROUTING (for altering incoming packets before routing) and OUTPUT (for altering locally-generated packets before routing). Since kernel 2.4.18, three other built-in chains are also supported: INPUT (for packets coming into the box itself), FORWARD (for altering packets being routed through the box), and POSTROUTING (for altering packets as they are about to go out).
			* raw: This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target. It registers at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables. It provides the following built-in chains: PREROUTING (for packets arriving via any network interface) OUTPUT (for packets generated by local processes)
	* -F, --flush [chain]
		* Flush the selected chain (all the chains in the table if none is given). This is equivalent to deleting all the rules one by one.

### iptables -Z
* TL;DR
	* Initialize packet/byte counters in all chains
* Details
	* -Z, --zero [chain]
		* Zero the packet and byte counters in all chains. It is legal to specify the -L, --list (list) option as well, to see the counters immediately before they are cleared. (See above.)

### iptables -A FORWARD -i <interface name> -j ACCEPT
* TL;DR
	* Add rule to filter(default) table. For any packet that passes through (interface name), let it through
* Details
	* -A, --append chain rule-specification
		* Append one or more rules to the end of the selected chain. When the source and/or destination names resolve to more than one address, a rule will be added for each possible address combination.
	* FORWARD
		* for altering packets being routed through the box
	* -i, --in-interface [!] name
		* Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
	* -j, --jump target
		* This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below). If this option is omitted in a rule (and -g is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
	* Targets
		* A firewall rule specifies criteria for a packet, and a target. If the packet does not match, the next rule in the chain is the examined; if it does match, then the next rule is specified by the value of the target, which can be the name of a user-defined chain or one of the special values ACCEPT, DROP, QUEUE, or RETURN.
		* ACCEPT means to let the packet through. DROP means to drop the packet on the floor. QUEUE means to pass the packet to userspace. (How the packet can be received by a userspace process differs by the particular queue handler. 2.4.x and 2.6.x kernels up to 2.6.13 include the ip_queue queue handler. Kernels 2.6.14 and later additionally include the nfnetlink_queue queue handler. Packets with a target of QUEUE will be sent to queue number '0' in this case. Please also see the NFQUEUE target as described later in this man page.) RETURN means stop traversing this chain and resume at the next rule in the previous (calling) chain. If the end of a built-in chain is reached or a rule in a built-in chain with target RETURN is matched, the target specified by the chain policy determines the fate of the packet.

### iptables -t nat -A POSTROUTING -o <interface name> -j MASQUERADE
* TL;DR
	* Add rule to nat table POSTROUTING chain so that outgoing packet's IP is changed to (interface name)'s IP (=IP Masquerading). This allows LAN nodes with private IP addresses to communicate with external public networks
* Details
	* POSTROUTING
		* for altering packets as they are about to go out
	* -o, --out-interface [!] name
		* Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
	* MASQUERADE
		* Mask the private IP address of a node with the external IP address of the firewall/gateway
		* This target is only valid in the nat table, in the POSTROUTING chain. It should only be used with dynamically assigned IP (dialup) connections: if you have a static IP address, you should use the SNAT target. Masquerading is equivalent to specifying a mapping to the IP address of the interface the packet is going out, but also has the effect that connections are forgotten when the interface goes down. This is the correct behavior when the next dialup is unlikely to have the same interface address (and hence any established connections are lost anyway). It takes one option:
			* --to-ports port[-port]: This specifies a range of source ports to use, overriding the default SNAT source port-selection heuristics (see above). This is only valid if the rule also specifies -p tcp or -p udp.

### iptables -t nat -A PREROUTING -p tcp --dport <port number 1> -j DNAT --to-destination <ip:port>
* TL;DR
	* For incoming packets that tries to make connection (nat table) to --dport port number, change its destination address to --to-destination ip:port
* Details
	* PREROUTING
		* for altering packets as soon as they come in
	* -p, --protocol [!] protocol
		* The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, icmp, or all, or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test. The number zero is equivalent to all. Protocol all will match with all protocols and is taken as default when this option is omitted.
	* DNAT
		* DNAT
			* This target is only valid in the nat table, in the PREROUTING and OUTPUT chains, and user-defined chains which are only called from those chains. It specifies that the destination address of the packet should be modified (and all future packets in this connection will also be mangled), and rules should cease being examined. It takes one type of option:
				* --to-destination ipaddr[-ipaddr][:port-port] : which can specify a single new destination IP address, an inclusive range of IP addresses, and optionally, a port range (which is only valid if the rule also specifies -p tcp or -p udp). If no port range is specified, then the destination port will never be modified. 
				* In Kernels up to 2.6.10 you can add several --to-destination options. For those kernels, if you specify more than one destination address, either via an address range or multiple --to-destination options, a simple round-robin (one after another in cycle) load balancing takes place between these addresses. Later Kernels (>= 2.6.11-rc1) don't have the ability to NAT to multiple ranges anymore.

